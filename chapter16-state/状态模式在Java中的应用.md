# 状态模式在Java中的应用

你想了解状态模式在Java中的实际应用，我会从**JDK内置应用**、**经典业务场景应用**、**应用优势**和**使用注意事项**四个维度展开，结合具体示例帮你理解其落地价值。

## 一、 JDK 中的内置应用（核心原生场景）

状态模式在Java核心类库中有明确的落地实现，最典型的是 **`java.util.concurrent.locks.Lock` 相关的状态管理**，其中最具代表性的是 `ReentrantLock`（可重入锁）的状态控制，以及其底层依赖的 `AbstractQueuedSynchronizer`（AQS，抽象队列同步器）。

### 1. 核心场景：ReentrantLock 的状态流转

`ReentrantLock` 作为可重入独占锁，存在「锁定」和「未锁定」两种核心状态，同时支持「公平锁」/「非公平锁」的状态细分，其状态管理完全遵循状态模式的设计思想：

- 抽象状态类（隐含）：AQS 中定义了锁状态的统一操作接口（如 `acquire()`、`release()` 等），规范了锁的获取与释放行为；

- 具体状态类（隐含）：`ReentrantLock` 的公平锁实现（`FairSync`）和非公平锁实现（`NonfairSync`），本质是两种具体状态类，封装了不同状态下的锁竞争逻辑；

- 环境类：`ReentrantLock` 自身作为环境类，维护了当前锁的状态（通过 AQS 的 `state` 变量记录重入次数，`state=0` 表示未锁定，`state>0` 表示锁定），并委托 `FairSync`/`NonfairSync` 执行具体的锁操作；

- 状态切换：当调用 `lock()` 方法时，锁状态从「未锁定」切换为「锁定」；调用 `unlock()` 方法时，锁状态从「锁定」逐步切换为「未锁定」（重入时需多次释放）。

### 2. 其他 JDK 应用场景

- **线程状态管理**：Java 线程（`Thread`）存在 `NEW`、`RUNNABLE`、`BLOCKED`、`WAITING`、`TIMED_WAITING`、`TERMINATED` 六种状态，线程的状态切换（如 `start()` 使线程从 `NEW`→`RUNNABLE`，`wait()` 使线程从 `RUNNABLE`→`WAITING`）本质是状态模式的思想体现，JVM 内部封装了各状态下的线程行为；

- **I/O 流状态管理**：Java I/O 流（如 `FileInputStream`、`BufferedReader`）存在「打开」和「关闭」两种状态，流对象的 `read()`、`write()` 方法仅在「打开」状态下有效，`close()` 方法会将流状态切换为「关闭」，后续操作会抛出 `IOException`，这也是状态模式的简化实现。

## 二、 经典业务场景应用（实际开发落地）

在Java业务开发中，状态模式广泛应用于「多状态、强流转」的场景，以下是3个最典型的落地案例，附核心实现思路：

### 1.  订单状态流转（最主流场景）

这是电商、外卖、票务等系统的核心场景，订单存在明确的状态层级和流转规则，状态模式是最优解决方案。

- 核心状态：待支付（UnPaid）→ 已支付（Paid）→ 已发货（Delivered）→ 已完成（Finished）→ 已取消（Cancelled）；

- 状态模式落地：
        

    1. 抽象状态接口：`OrderState`，定义 `pay()`、`deliver()`、`finish()`、`cancel()` 等统一行为；

    2. 具体状态类：`UnPaidState`、`PaidState` 等，封装各状态下的合法操作与状态切换逻辑（如 `UnPaidState` 中 `pay()` 方法执行支付逻辑后，将订单状态切换为 `PaidState`）；

    3. 环境类：`OrderContext`，维护当前订单状态，提供客户端交互接口（`payOrder()`、`deliverOrder()` 等），委托具体状态类执行业务逻辑；

- 核心价值：替代大量 `if-else`/`switch-case`（如「只有待支付订单才能取消」「只有已支付订单才能发货」等判断），新增状态（如「待退款」）时只需新增具体状态类，无需修改现有代码。

### 2.  电梯状态控制（经典教学/实际工控场景）

在楼宇控制系统、仿真系统中，电梯的状态管理是状态模式的典型应用，电梯存在明确的状态依赖行为。

- 核心状态：停止（Stop）→ 开门（Open）→ 关门（Close）→ 运行（Run）；

- 状态模式落地：
        

    1. 抽象状态接口：`ElevatorState`，定义 `openDoor()`、`closeDoor()`、`run()`、`stop()` 等行为；

    2. 具体状态类：`StopState`、`OpenState` 等，封装各状态下的合法操作（如 `OpenState` 中禁止执行 `run()` 方法，提示「电梯门未关闭，禁止运行」；`RunState` 中 `stop()` 方法切换状态为 `StopState`）；

    3. 环境类：`ElevatorContext`，维护当前电梯状态，接收用户操作并委托状态对象执行；

- 核心价值：确保电梯操作的合法性，避免非法操作（如运行中开门），状态流转清晰可控，便于维护。

### 3.  游戏角色状态管理（游戏开发场景）

在Java游戏开发中，角色状态的动态切换依赖状态模式，不同状态下角色的行为存在显著差异。

- 核心状态：正常（Normal）→ 受伤（Hurt）→ 无敌（Invincible）→ 死亡（Dead）；

- 状态模式落地：
        

    1. 抽象状态接口：`RoleState`，定义 `attack()`、`beAttacked()`、`move()` 等角色核心行为；

    2. 具体状态类：`NormalState`、`HurtState` 等，封装各状态下的行为逻辑（如 `HurtState` 中角色移动速度降低，`InvincibleState` 中 `beAttacked()` 方法无效，`DeadState` 中角色无法执行攻击/移动操作）；

    3. 环境类：`RoleContext`，维护游戏角色的当前状态，接收游戏引擎的指令并委托状态对象执行；

- 核心价值：灵活扩展角色状态（如新增「中毒」「眩晕」状态），无需修改现有角色行为逻辑，提高游戏代码的可维护性。

## 三、 状态模式在Java应用中的核心优势

1. **消除冗余分支判断**：彻底解决「状态越多，`if-else`/`switch-case` 越臃肿」的问题，代码可读性和可维护性大幅提升；

2. **状态逻辑隔离封装**：每个状态的行为逻辑被封装在独立的具体状态类中，职责单一，便于单独测试、修改和扩展；

3. **符合开闭原则**：新增状态时，只需新增具体状态类，无需修改环境类和其他现有状态类的代码，降低代码耦合度；

4. **状态流转清晰可控**：状态切换逻辑要么封装在具体状态类中（业务驱动），要么在环境类中统一管理（规则驱动），避免状态混乱导致的业务异常；

5. **行为与状态解耦**：环境类无需关注各状态下的具体行为实现，只需委托给当前状态对象，符合「迪米特法则」。

## 四、 Java中使用状态模式的注意事项

1. **状态数量适中时使用**：如果对象只有2-3种状态，且状态流转简单，使用 `if-else` 可能比状态模式更简洁（避免类爆炸）；当状态数量≥4种，且流转复杂时，状态模式的优势才会凸显；

2. **避免不必要的状态切换**：状态切换逻辑应尽量封装在具体状态类中，避免在客户端手动切换状态，防止非法状态流转；

3. **可结合单例模式优化**：如果具体状态类无状态（即不包含成员变量，行为固定），可将其设计为单例（如通过静态常量或枚举实现），减少对象创建的内存开销；

4. **与策略模式区分**：状态模式关注「对象状态的动态切换，行为随状态变化」，策略模式关注「算法的灵活替换，算法之间无状态依赖」，避免混淆使用。

## 总结

1. 状态模式在Java中的应用分为两大类型：**JDK内置原生应用**（如 ReentrantLock、线程状态）和**业务开发落地应用**（如订单状态、电梯控制、游戏角色状态）；

2. 核心适用场景：对象存在多种状态、行为依赖于状态、状态流转明确，且存在大量状态相关分支判断的场景；

3. 核心价值：提高代码可读性、可维护性和扩展性，消除冗余分支判断，规范状态流转逻辑；

4. 使用要点：根据状态数量选择是否使用，避免类爆炸，合理封装状态切换逻辑。
> （注：文档部分内容可能由 AI 生成）