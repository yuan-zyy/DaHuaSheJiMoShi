# 中介者模式与观察者模式的核心区别

中介者模式和观察者模式均属于行为型设计模式，核心目标都是解耦对象间的交互，但二者的设计思路、交互逻辑和适用场景存在本质差异。以下从**核心思想、交互方式、角色关系、依赖方向、适用场景**等关键维度，结合实例进行详细对比，明确二者的区别与边界。

## 一、核心思想：“集中协调” vs “分散通知”

两种模式的核心差异源于对“解耦”方式的不同理解，这也是后续所有区别的根源：

**中介者模式**：核心是“**集中协调**”。通过引入一个“中介者”对象，封装多个对象（同事类）之间的所有交互逻辑，让同事类之间不再直接通信，而是通过中介者间接交互。本质是将多对多的网状交互关系，转化为同事类与中介者之间的一对多关系，实现交互逻辑的集中管理。

**观察者模式**：核心是“**分散通知**”。定义了“主题-观察者”的一对多依赖关系，当主题对象的状态发生变化时，会自动通知所有依赖它的观察者对象，观察者根据通知做出响应。本质是让观察者被动接收主题的状态变更，交互逻辑分散在主题和各个观察者中，无统一协调中心。

## 二、交互方式：“双向间接通信” vs “单向通知推送”

对象间的交互流向和触发方式，是二者最直观的区别：

### 1. 中介者模式：双向、间接的交互

同事类之间的交互是**双向**的，且必须通过中介者中转：

- 当一个同事类发生状态变化或需要发起交互时，它会主动将消息发送给中介者；

- 中介者接收消息后，根据预设的协调逻辑，决定将消息转发给哪些其他同事类；

- 接收消息的同事类做出响应，完成一次交互。

示例：多人聊天室（中介者模式）。用户A发送消息时，不会直接发给用户B、C，而是将消息交给聊天室（中介者），由聊天室统一转发给其他用户；用户B回复消息时，同样通过聊天室转发给A和C，交互是双向且经过中介的。

### 2. 观察者模式：单向、主动的通知

交互是**单向**的，仅从主题流向观察者，无反向交互：

- 观察者需先向主题注册，表明自己要“监听”主题的状态变化；

- 当主题的状态发生变化时，会主动向所有已注册的观察者推送通知（无需观察者主动请求）；

- 观察者接收通知后，根据通知内容更新自身状态，不会反向向主题或其他观察者发送消息。

示例：天气预警系统（观察者模式）。气象站（主题）监测到暴雨天气后，主动向所有订阅了“天气预警”的APP（观察者）推送通知；APP接收后更新界面提示用户，不会向气象站或其他APP反馈信息，交互是单向的。

## 三、角色关系：“多对一（同事-中介）” vs “一对多（主题-观察者）”

两种模式的角色构成和依赖关系完全不同，具体对比如下表：

|维度|中介者模式|观察者模式|
|---|---|---|
|核心角色|抽象中介者、具体中介者、抽象同事类、具体同事类|抽象主题（Subject）、具体主题（ConcreteSubject）、抽象观察者（Observer）、具体观察者（ConcreteObserver）|
|角色关系|所有同事类依赖于同一个中介者（多对一）；中介者持有所有同事类的引用，负责协调|一个主题对应多个观察者（一对多）；主题不持有观察者的具体逻辑，仅负责通知|
|依赖方向|同事类 → 中介者（同事类必须知道中介者的存在，才能发起交互）|观察者 → 主题（观察者主动注册到主题，主题无需知道观察者的具体实现）|
|角色独立性|同事类独立性强（无需关注其他同事类），但依赖中介者|观察者独立性极强（无需关注其他观察者和主题的具体逻辑），主题也独立于观察者|
## 四、依赖方向：“强依赖中介” vs “弱依赖主题”

二者的依赖强度和灵活性存在差异：

**中介者模式**：同事类对中介者是**强依赖**。所有同事类的交互都必须通过中介者，若中介者发生变更（如修改协调逻辑、替换中介者实现），所有同事类无需修改；但如果没有中介者，同事类之间无法直接交互，系统无法正常工作。

**观察者模式**：观察者对主题是**弱依赖**。观察者可以随时注册或取消注册，主题仅需维护一个观察者列表，无需关心观察者的具体实现；即使没有观察者，主题依然可以独立存在（如气象站监测天气，即使没有APP订阅，依然会记录天气数据）。

## 五、适用场景：“解决多对象复杂交互” vs “监听状态变更通知”

两种模式的适用场景完全不同，需根据业务需求选择：

### 1. 中介者模式的适用场景

核心解决“**多个对象之间存在复杂交互、形成网状依赖**”的问题，典型场景：

- 多人协作场景：如聊天室、协同编辑工具（多个用户编辑同一文档，需中介者协调内容同步）；

- 系统模块协调：如电商订单系统（订单模块、库存模块、支付模块之间的交互，由订单中介者协调）；

- UI组件交互：如表单页面（按钮、输入框、弹窗等组件的交互，由中介者统一管理，避免组件间直接依赖）。

### 2. 观察者模式的适用场景

核心解决“**一个对象状态变更，需要通知多个对象并触发更新**”的问题，典型场景：

- 状态通知场景：如天气预警、股票行情推送、消息订阅系统；

- 事件响应场景：如UI按钮点击事件（按钮是主题，点击后通知所有监听该事件的组件执行响应逻辑）；

- 日志收集场景：如系统日志模块（主题），当系统产生日志时，通知日志存储组件、日志分析组件等（观察者）进行处理。

## 六、核心区别总结

1. 核心目标不同：中介者模式聚焦“**简化多对象间的复杂交互**”，观察者模式聚焦“**状态变更的通知与响应**”；

2. 交互方向不同：中介者模式是**双向交互**，观察者模式是**单向通知**；

3. 依赖关系不同：中介者模式中同事类**强依赖**中介者，观察者模式中观察者与主题是**弱依赖**；

4. 逻辑集中程度不同：中介者模式的交互逻辑**集中在中介者**中，观察者模式的逻辑**分散在主题和观察者**中。

## 七、补充：二者的结合使用

实际开发中，两种模式并非互斥，可结合使用：例如，在聊天室系统（中介者模式）中，当聊天室（中介者）接收到用户消息后，需要通知所有在线用户（观察者）。此时，聊天室可作为“主题”，用户作为“观察者”，通过观察者模式实现消息的批量推送；而用户之间的交互仍通过聊天室（中介者）协调，兼顾了集中协调和批量通知的需求。
> （注：文档部分内容可能由 AI 生成）