# 命令模式实现原理（结合代码示例）

你希望通过代码示例理解命令模式的实现原理，命令模式的核心实现逻辑是**将请求封装为独立命令对象，通过四大核心角色的协作，实现请求发送者与接收者的解耦，同时支持命令的灵活管理**。下面我们先拆解实现原理核心，再通过完整代码示例逐一对应说明。

## 一、命令模式实现原理核心

### 1. 核心思想

将「请求的发起」（谁要发请求）、「请求的执行」（谁来做这件事）、「请求本身」（要做什么事）三者解耦，通过「命令对象」作为中间桥梁，让调用者无需知晓接收者的存在和业务实现细节，仅通过命令对象即可触发业务执行。

### 2. 四大核心角色协作流程（实现原理关键）

1. **命令接口（Command）**：定义统一的命令执行规范（核心方法 `execute()`，可选 `undo()`），是所有具体命令的抽象，保证调用者能以统一方式触发不同命令。

2. **具体命令（ConcreteCommand）**：


    - 持有「接收者对象」的引用（通过构造方法注入，建立命令与接收者的绑定关系）；

    - 实现命令接口的 `execute()` 方法，在该方法内部**调用接收者的具体业务方法**（这是命令执行的核心：命令本身不做业务，只是转发请求给接收者）。

3. **接收者（Receiver）**：真正执行业务逻辑的类，包含具体的业务操作（如开机、关机、复制、粘贴等），对命令无感知，仅负责处理核心业务。

4. **调用者（Invoker）**：
       

    - 持有「命令对象」的引用（支持动态设置/切换命令）；

    - 提供触发命令的方法（如 `pressButton()`），在该方法内部仅调用命令对象的 `execute()` 方法，不直接与接收者交互。

### 3. 整体执行流程（核心链路）

`客户端` → 初始化（接收者 + 具体命令（绑定接收者） + 调用者（绑定命令）） → `调用者` 触发命令（如 `pressExecuteButton()`） → `具体命令` 转发请求（调用 `接收者` 的业务方法） → `接收者` 执行核心业务 → 完成请求处理

## 二、完整代码示例（对应实现原理）

我们以「文档编辑器的复制/粘贴功能」为场景（更贴近实际开发），逐一对应四大角色，拆解实现原理：

### 1. 角色1：命令接口（Command）—— 定义统一执行规范

对应原理：抽象所有命令的公共方法，保证调用者（编辑器按钮）能以统一方式触发复制、粘贴命令。

```java

/**
 * 命令接口：定义命令的统一执行规范（实现原理核心：统一命令调用标准）
 */
public interface Command {
    // 核心执行方法：所有命令必须实现该方法，用于触发业务执行
    void execute();
    
    // 可选：撤销方法（体现命令模式的可撤销特性，也是基于统一接口实现）
    default void undo() {}
}
```

### 2. 角色2：接收者（Receiver）—— 真正执行业务逻辑

对应原理：负责处理核心业务，与命令解耦，仅提供业务方法，不感知命令的存在。

```java

/**
 * 接收者：文档编辑器（真正执行业务逻辑的类）
 * 对应原理：所有命令的最终业务落地者，提供复制、粘贴、撤销粘贴等具体业务
 */
public class DocumentEditor {
    // 业务方法1：复制文档内容
    public void copyContent() {
        System.out.println("文档编辑器：已复制选中的文本内容到剪贴板");
    }
    
    // 业务方法2：粘贴剪贴板内容
    public void pasteContent() {
        System.out.println("文档编辑器：已将剪贴板内容粘贴到文档中");
    }
    
    // 业务方法3：撤销粘贴操作（用于命令撤销）
    public void undoPaste() {
        System.out.println("文档编辑器：已撤销上一步的粘贴操作");
    }
}
```

### 3. 角色3：具体命令（ConcreteCommand）—— 封装请求+转发给接收者

对应原理：持有接收者引用，实现命令接口，在 `execute()` 中调用接收者业务方法，完成请求转发。

```java

/**
 * 具体命令1：复制命令（绑定文档编辑器，转发复制请求）
 */
public class CopyCommand implements Command {
    // 持有接收者（文档编辑器）的引用：建立命令与接收者的绑定
    private DocumentEditor editor;
    
    // 构造方法注入接收者：灵活绑定不同接收者（符合依赖注入思想）
    public CopyCommand(DocumentEditor editor) {
        this.editor = editor;
    }
    
    @Override
    public void execute() {
        // 核心实现：命令本身不做业务，仅调用接收者的对应业务方法
        editor.copyContent();
    }
}

/**
 * 具体命令2：粘贴命令（绑定文档编辑器，转发粘贴请求，支持撤销）
 */
public class PasteCommand implements Command {
    // 持有接收者引用：绑定文档编辑器
    private DocumentEditor editor;
    
    public PasteCommand(DocumentEditor editor) {
        this.editor = editor;
    }
    
    @Override
    public void execute() {
        // 核心实现：转发请求给接收者的粘贴业务方法
        editor.pasteContent();
    }
    
    @Override
    public void undo() {
        // 撤销逻辑：转发请求给接收者的撤销粘贴方法
        editor.undoPaste();
    }
}
```

### 4. 角色4：调用者（Invoker）—— 触发命令执行（不直接操作接收者）

对应原理：持有命令对象，提供触发方法，仅调用命令的 `execute()`，与接收者完全解耦，支持动态切换命令。

```java

/**
 * 调用者：编辑器工具栏按钮（触发命令执行的角色）
 * 对应原理：不感知接收者，仅与命令对象交互，统一触发命令
 */
public class EditorToolbar {
    // 持有当前命令对象（支持动态切换）
    private Command currentCommand;
    
    // 动态设置命令：灵活切换不同命令（如从复制切换到粘贴）
    public void setCommand(Command command) {
        this.currentCommand = command;
    }
    
    // 触发命令执行（对应工具栏按钮点击事件）
    public void clickButton() {
        if (currentCommand != null) {
            // 核心实现：仅调用命令的execute方法，无需关心业务细节
            currentCommand.execute();
        } else {
            System.out.println("工具栏：未绑定任何命令，无法执行！");
        }
    }
    
    // 触发命令撤销（对应工具栏的撤销按钮）
    public void clickUndoButton() {
        if (currentCommand != null) {
            currentCommand.undo();
        } else {
            System.out.println("工具栏：未绑定任何命令，无法撤销！");
        }
    }
}
```

### 5. 客户端（Client）—— 初始化角色+组装流程

对应原理：负责创建所有角色实例，建立角色间的绑定关系，触发整个命令执行链路。

```java

/**
 * 客户端：使用编辑器工具栏
 * 对应原理：组装四大角色，触发命令执行链路
 */
public class CommandPatternDemo {
    public static void main(String[] args) {
        // 1. 创建接收者（真正做业务的文档编辑器）
        DocumentEditor editor = new DocumentEditor();
        
        // 2. 创建具体命令（绑定接收者，建立命令与业务的关联）
        Command copyCmd = new CopyCommand(editor);
        Command pasteCmd = new PasteCommand(editor);
        
        // 3. 创建调用者（工具栏按钮，不感知接收者）
        EditorToolbar toolbar = new EditorToolbar();
        
        // 4. 组装并触发「复制命令」（对应执行流程：调用者→命令→接收者）
        System.out.println("=== 执行复制操作 ===");
        toolbar.setCommand(copyCmd);
        toolbar.clickButton(); // 调用者触发命令 → 复制命令转发 → 编辑器执行复制业务
        
        // 5. 组装并触发「粘贴命令」
        System.out.println("\n=== 执行粘贴操作 ===");
        toolbar.setCommand(pasteCmd);
        toolbar.clickButton(); // 调用者触发命令 → 粘贴命令转发 → 编辑器执行粘贴业务
        
        // 6. 触发「撤销粘贴」操作
        System.out.println("\n=== 执行撤销粘贴操作 ===");
        toolbar.clickUndoButton(); // 调用者触发撤销 → 粘贴命令转发 → 编辑器执行撤销粘贴业务
    }
}
```

### 6. 运行结果（对应执行链路）

```text

=== 执行复制操作 ===
文档编辑器：已复制选中的文本内容到剪贴板

=== 执行粘贴操作 ===
文档编辑器：已将剪贴板内容粘贴到文档中

=== 执行撤销粘贴操作 ===
文档编辑器：已撤销上一步的粘贴操作
```

## 三、 关键原理拆解（对应代码细节）

1. **解耦的核心体现**：
        

    - 调用者（`EditorToolbar`）仅持有 `Command` 接口引用，不知道接收者（`DocumentEditor`）的存在，也不知道 `copyContent()`、`pasteContent()` 这些业务方法；

    - 新增命令（如「剪切命令」）时，只需新增 `CutCommand` 实现 `Command` 接口，无需修改 `EditorToolbar` 和 `DocumentEditor`，符合「开闭原则」。

2. **命令封装的核心体现**：
        

    - `CopyCommand` 和`PasteCommand` 就是封装后的请求对象，它们包含了「要执行的业务」（复制/粘贴）和「执行业务的对象」（`DocumentEditor`）；

    - 可以将这些命令对象存入集合（如 `List<Command>`），实现命令队列（批量执行复制、粘贴操作），这是命令模式支持批量处理的原理基础。

3. **可撤销的实现原理**：
        

    - 通过命令接口的 `undo()` 方法，在具体命令中实现「逆向业务操作」（如 `PasteCommand` 的 `undo()` 调用 `editor.undoPaste()`）；

    - 只需在调用者中提供触发 `undo()` 的方法（如 `clickUndoButton()`），即可实现命令回滚，无需修改其他角色。

## 总结

命令模式的实现原理可概括为3点：

1. 核心：**封装请求为命令对象**，以四大角色（命令接口→具体命令→接收者→调用者）协作实现解耦；

2. 关键：具体命令持有接收者引用，在 `execute()` 中转发请求给接收者的业务方法，调用者仅与命令接口交互；

3. 链路：客户端组装角色 → 调用者触发命令 → 具体命令转发请求 → 接收者执行业务，完成整个请求处理。
> （注：文档部分内容可能由 AI 生成）