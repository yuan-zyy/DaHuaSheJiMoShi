## 工厂方法模式在量化交易系统的实战案例
以***量化交易策略的动态创建与扩展***为场景(这是量化系统的核心场景之一)，完整实现工厂方法模式的四大角色，并展示其扩展性优势

### 一、场景背景
量化交易系统中，常见的交易策略有：
1. MACrossStrategy(均线交叉策略: 短期均线上穿长期均线买入，下穿卖出)
2. RSIStrategy(RSI超买超卖策略: RSI > 70卖出，RSI < 30 买入)</br>
后续可能新增 BollingerBandStrategy(布林带策略)等，需保证系统无需修改原有代码即可扩展，这正是工厂方法模式的适用场景

### 二、完整实战代码
#### 1. 抽象产品(Product) - 交易策略接口
定义所有量化交易策略的公共行为(初始化、执行策略、释放资源)，是所有具体策略的统一规范

```java
import java.time.LocalDateTime;
import java.util.List;

/**
 * 抽象产品: 量化交易策略接口
 * 定义所有交易策略的公共方法
 */
public interface TradingStrategy {
    // 初始化策略(加载参数: 均线周期、RSI周期等)
    void initStrategy(StrategyParam param);

    // 执行交易策略(传入行情数据，返回交易信号: 买入/卖出/持有)
    TradingSignal executeStrategy(MarketData marketData);

    // 释放策略资源(关闭文件、释放连接等)
    void destroyStrategy();
}

/**
 * 策略参数类(辅助类): 存储不同策略的配置参数
 */
public class StrategyParam {
    // 均线策略参数: 短期均线周期、长期均线周期
    private int shortMaPeriod;
    private int longMaPeriod;
    // RSI 策略参数: RSI 周期
    private int rsiPeriod;
    // 通用参数: 策略名称
    private String strategyName;

    // 省略构造器、getter/setter方法
    public StrategyParam() {
    }

    public StrategyParam(int shortMaPeriod, int longMaPeriod, int rsiPeriod, String strategyName) {
        this.shortMaPeriod = shortMaPeriod;
        this.longMaPeriod = longMaPeriod;
        this.rsiPeriod = rsiPeriod;
        this.strategyName = strategyName;
    }

    public int getShortMaPeriod() {
        return shortMaPeriod;
    }

    public void setShortMaPeriod(int shortMaPeriod) {
        this.shortMaPeriod = shortMaPeriod;
    }

    public int getLongMaPeriod() {
        return longMaPeriod;
    }

    public void setLongMaPeriod(int longMaPeriod) {
        this.longMaPeriod = longMaPeriod;
    }

    public int getRsiPeriod() {
        return rsiPeriod;
    }

    public void setRsiPeriod(int rsiPeriod) {
        this.rsiPeriod = rsiPeriod;
    }

    public String getStrategyName() {
        return strategyName;
    }

    public void setStrategyName(String strategyName) {
        this.strategyName = strategyName;
    }
}

/**
 * 交易信号枚举(辅助类: 定义策略执行结果)
 */
public enum TradingSignal {
    BUY("买入"),
    SELL("卖出"),
    HOLD("持有");

    private String desc;

    TradingSignal(String desc) {
        this.desc = desc;
    }

    public String getDesc() {
        return desc;
    }
}

/**
 * 行情数据类(辅助类: 存储股票/期货的K线行情数据)
 */
public class MarketData {
    // 股票代码
    private String code;
    // 收盘价列表(用于计算均线、RSI)
    private List<Double> closePriceList;
    // 当前时间
    private LocalDateTime tradeTime;

    // 省略构造器、getter/setter方法
    public MarketData() {}

    public MarketData(String code, List<Double> closePriceList, LocalDateTime tradeTime) {
        this.code = code;
        this.closePriceList = closePriceList;
        this.tradeTime = tradeTime;
    }

    public String getCode() { return code; }
    
    public void setCode(String code) { 
        this.code = code; 
    }
    
    public List<Double> getClosePriceList() { 
        return closePriceList; 
    }
    
    public void setClosePriceList(List<Double> closePriceList) { 
        this.closePriceList = closePriceList; 
    }
    
    public LocalDateTime getTradeTime() { 
        return tradeTime; 
    }
    
    public void setTradeTime(LocalDateTime tradeTime) { 
        this.tradeTime = tradeTime; 
    }
    
}
```

#### 2. 具体产品(Concrete Product) - 具体交易策略
实现抽象策略接口，分别封装均线交叉策略和RSI策略的核心逻辑

```java
import java.util.List;

/**
 * 具体产品1: 均线交叉策略
 */
public class MACrossStrategy implements TradingStrategy {
    private int shortMaPeriod;  // 短期均线周期(如5日线)
    private int longMaPeriod;   // 长期均线周期(如20日线)

    @Override
    public void initStrategy(StrategyParam param) {
        // 初始化均线参数
        this.shortMaPeriod = param.getShortMaPeriod();
        this.longMaPeriod = param.getLongMaPeriod();
        System.out.println("均线交叉策略初始化完成: 短线周期 = " + shortMaPeriod + ", 长线周期 = " + longMaPeriod);
    }

    @Override
    public TradingSignal executeStrategy(MarketData marketData) {
        List<Double> closePrices = marketData.getClosePriceList();
        // 数据不足时，返回持有信号
        if (closePrices.size() < longMaPeriod) {
            System.out.println("均线策略数据不足，无法执行，返回持有信号");
            return TradingSignal.HOLD;
        }

        // 计算短期均线和长期均线（简单算术平均）
        double shortMa = calculateMA(closePrices, shortMaPeriod);
        double longMa = calculateMA(closePrices, longMaPeriod);
        System.out.println("当前短期均线=" + String.format("%.2f", shortMa) + "，长期均线=" + String.format("%.2f", longMa));

        // 均线交叉逻辑：金叉（短期上穿长期）买入，死叉（短期下穿长期）卖出
        double prevShortMa = calculatePrevMA(closePrices, shortMaPeriod);
        double prevLongMa = calculatePrevMA(closePrices, longMaPeriod);

        if (prevShortMa <= prevLongMa && shortMa > longMa) {
            System.out.println("出现金叉信号，返回买入信号");
            return TradingSignal.BUY;
        } else if (prevShortMa >= prevLongMa && shortMa < longMa) {
            System.out.println("出现死叉信号，返回卖出信号");
            return TradingSignal.SELL;
        } else {
            System.out.println("均线无交叉，返回持有信号");
            return TradingSignal.HOLD;
        }
    }

    @Override
    public void destroyStrategy() {
        System.out.println("均线交叉策略资源释放完成");
    }

    // 辅助方法：计算最新均线值
    private double calculateMA(List<Double> closePrices, int period) {
        int size = closePrices.size();
        double sum = 0.0;
        for (int i = size - period; i < size; i++) {
            sum += closePrices.get(i);
        }
        return sum / period;
    }

    // 辅助方法：计算上一个周期的均线值
    private double calculatePrevMA(List<Double> closePrices, int period) {
        int size = closePrices.size();
        double sum = 0.0;
        for (int i = size - period - 1; i < size - 1; i++) {
            sum += closePrices.get(i);
        }
        return sum / period;
    }
}

/**
 * 具体产品2：RSI超买超卖策略
 */
public class RSIStrategy implements TradingStrategy {
    private int rsiPeriod; // RSI计算周期（如14日）

    @Override
    public void initStrategy(StrategyParam param) {
        // 初始化RSI参数
        this.rsiPeriod = param.getRsiPeriod();
        System.out.println("RSI策略初始化完成：RSI周期=" + rsiPeriod);
    }

    @Override
    public TradingSignal executeStrategy(MarketData marketData) {
        List<Double> closePrices = marketData.getClosePriceList();
        // 数据不足时，返回持有信号
        if (closePrices.size() < rsiPeriod + 1) {
            System.out.println("RSI策略数据不足，无法执行，返回持有信号");
            return TradingSignal.HOLD;
        }

        // 计算RSI值（简化版：仅计算相对强弱指数）
        double rsi = calculateRSI(closePrices, rsiPeriod);
        System.out.println("当前RSI值=" + String.format("%.2f", rsi));

        // RSI策略逻辑：RSI>70超买卖出，RSI<30超卖买入，中间持有
        if (rsi > 70) {
            System.out.println("RSI超买，返回卖出信号");
            return TradingSignal.SELL;
        } else if (rsi < 30) {
            System.out.println("RSI超卖，返回买入信号");
            return TradingSignal.BUY;
        } else {
            System.out.println("RSI处于正常区间，返回持有信号");
            return TradingSignal.HOLD;
        }
    }

    @Override
    public void destroyStrategy() {
        System.out.println("RSI策略资源释放完成");
    }

    // 辅助方法：计算RSI值（简化版）
    private double calculateRSI(List<Double> closePrices, int period) {
        double upSum = 0.0; // 上涨幅度总和
        double downSum = 0.0; // 下跌幅度总和

        for (int i = closePrices.size() - period; i < closePrices.size(); i++) {
            double diff = closePrices.get(i) - closePrices.get(i - 1);
            if (diff > 0) {
                upSum += diff;
            } else {
                downSum += Math.abs(diff);
            }
        }

        // 避免除0异常
        if (downSum == 0) {
            return 100.0;
        }
        double rs = upSum / downSum;
        return 100 - (100 / (1 + rs));
    }
}
```

#### 3. 抽象工厂(Creator) - 策略工厂接口
定义创建交易策略的工厂方法，返回抽象策略类型，不直接参与具体策略的创建
```java
/**
 * 抽象工厂：交易策略工厂接口
 * 定义创建交易策略的统一方法
 */
public interface TradingStrategyFactory {
    // 工厂方法：创建具体交易策略实例
    TradingStrategy createTradingStrategy();
}
```

#### 4. 具体工厂（Concrete Creator）- 具体策略工厂
分别实现均线策略工厂和 RSI 策略工厂，重写工厂方法，负责创建对应具体策略实例
```java
/**
 * 具体工厂1：均线交叉策略工厂
 * 负责创建MACrossStrategy实例
 */
public class MACrossStrategyFactory implements TradingStrategyFactory {
    @Override
    public TradingStrategy createTradingStrategy() {
        // 可封装复杂的策略创建逻辑（如初始化默认参数、加载配置等）
        System.out.println("均线交叉策略工厂：创建均线策略实例");
        return new MACrossStrategy();
    }
}

/**
 * 具体工厂2：RSI策略工厂
 * 负责创建RSIStrategy实例
 */
public class RSIStrategyFactory implements TradingStrategyFactory {
    @Override
    public TradingStrategy createTradingStrategy() {
        System.out.println("RSI策略工厂：创建RSI策略实例");
        return new RSIStrategy();
    }
}
```
#### 5. 客户端测试代码
模拟量化交易系统的策略执行流程，展示如何通过工厂获取策略、初始化并执行
```java
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * 客户端：量化交易系统测试
 */
public class QuantTradingSystemTest {
    public static void main(String[] args) {
        // 1. 构造测试行情数据（股票代码：600036，收盘价列表，当前时间）
        List<Double> closePrices = new ArrayList<>();
        // 模拟15个交易日收盘价（用于均线（5/10）和RSI（14）计算）
        closePrices.add(10.0);
        closePrices.add(10.2);
        closePrices.add(9.8);
        closePrices.add(10.5);
        closePrices.add(10.8); // 第5天
        closePrices.add(11.0);
        closePrices.add(11.5);
        closePrices.add(12.0);
        closePrices.add(11.8);
        closePrices.add(12.5); // 第10天
        closePrices.add(13.0);
        closePrices.add(13.2);
        closePrices.add(12.8);
        closePrices.add(13.5);
        closePrices.add(14.0); // 第15天
        MarketData marketData = new MarketData("600036", closePrices, LocalDateTime.now());

        // 2. 构造策略参数
        StrategyParam maParam = new StrategyParam(5, 10, 0, "均线交叉策略");
        StrategyParam rsiParam = new StrategyParam(0, 0, 14, "RSI策略");

        // ========== 使用均线策略工厂创建并执行策略 ==========
        System.out.println("========== 均线交叉策略执行 ==========");
        TradingStrategyFactory maFactory = new MACrossStrategyFactory();
        TradingStrategy maStrategy = maFactory.createTradingStrategy();
        maStrategy.initStrategy(maParam);
        TradingSignal maSignal = maStrategy.executeStrategy(marketData);
        System.out.println("均线策略最终信号：" + maSignal.getDesc());
        maStrategy.destroyStrategy();

        System.out.println("======================================");

        // ========== 使用RSI策略工厂创建并执行策略 ==========
        System.out.println("========== RSI策略执行 ==========");
        TradingStrategyFactory rsiFactory = new RSIStrategyFactory();
        TradingStrategy rsiStrategy = rsiFactory.createTradingStrategy();
        rsiStrategy.initStrategy(rsiParam);
        TradingSignal rsiSignal = rsiStrategy.executeStrategy(marketData);
        System.out.println("RSI策略最终信号：" + rsiSignal.getDesc());
        rsiStrategy.destroyStrategy();
    }
}
```

#### 6. 运行结果
```text
========== 均线交叉策略执行 ==========
均线交叉策略工厂：创建均线策略实例
均线交叉策略初始化完成：短期均线=5，长期均线=10
当前短期均线=13.30，长期均线=12.48
出现金叉信号，返回买入信号
均线策略最终信号：买入
均线交叉策略资源释放完成
======================================
========== RSI策略执行 ==========
RSI策略工厂：创建RSI策略实例
RSI策略初始化完成：RSI周期=14
当前RSI值=76.92
RSI超买，返回卖出信号
RSI策略最终信号：卖出
RSI策略资源释放完成
```

### 三、扩展性演示（核心优势体现）
当需要新增 ** 布林带策略（BollingerBandStrategy）** 时，无需修改任何原有代码，只需新增两个类：
1. 具体产品：BollingerBandStrategy（实现TradingStrategy接口）
2. 具体工厂：BollingerBandStrategyFactory（实现TradingStrategyFactory接口）

示例代码（简化版）：
```java
// 新增具体产品：布林带策略
public class BollingerBandStrategy implements TradingStrategy {
    @Override
    public void initStrategy(StrategyParam param) {
        System.out.println("布林带策略初始化完成");
    }

    @Override
    public TradingSignal executeStrategy(MarketData marketData) {
        System.out.println("布林带策略执行，返回持有信号");
        return TradingSignal.HOLD;
    }

    @Override
    public void destroyStrategy() {
        System.out.println("布林带策略资源释放完成");
    }
}

// 新增具体工厂：布林带策略工厂
public class BollingerBandStrategyFactory implements TradingStrategyFactory {
    @Override
    public TradingStrategy createTradingStrategy() {
        System.out.println("布林带策略工厂：创建布林带策略实例");
        return new BollingerBandStrategy();
    }
}
```

客户端直接使用新工厂即可，原有代码完全无侵入：
```text
// 新增布林带策略执行（客户端无需修改原有逻辑）
System.out.println("========== 布林带策略执行 ==========");
TradingStrategyFactory bollFactory = new BollingerBandStrategyFactory();
TradingStrategy bollStrategy = bollFactory.createTradingStrategy();
bollStrategy.initStrategy(new StrategyParam());
TradingSignal bollSignal = bollStrategy.executeStrategy(marketData);
System.out.println("布林带策略最终信号：" + bollSignal.getDesc());
bollStrategy.destroyStrategy();
```

### 四、实战总结
1. 该场景完美契合工厂方法模式的核心价值：策略扩展无侵入，符合开闭原则。
2. 四大角色对应清晰：
   - 抽象产品：TradingStrategy（策略接口）
   - 具体产品：MACrossStrategy、RSIStrategy（具体策略）
   -抽象工厂：TradingStrategyFactory（策略工厂接口）
   - 具体工厂：MACrossStrategyFactory、RSIStrategyFactory（具体策略工厂）
3. 实际量化系统中，还可结合配置文件（如 XML/yml）动态指定工厂类，实现策略的无代码切换，进一步提升灵活性