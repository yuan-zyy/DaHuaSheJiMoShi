# 基于抽象工厂模式的多对象存储设计方案

# 基于抽象工厂模式的多对象存储（MinIO/OBS/OSS）设计方案

你需要设计一套支持MinIO、华为OBS、阿里云OSS三种对象存储的方案，且能通过配置文件动态切换存储方式，抽象工厂模式是最优选择（三种存储对应三个产品族，对象存储的核心操作对应统一产品类型）。以下是完整的分层设计、代码实现和配置切换方案。

## 一、核心设计思路

### 1. 模式角色对应（抽象工厂模式）

|抽象工厂模式角色|本方案具体实现|
|---|---|
|抽象产品（Abstract Product）|`ObjectStorage`（对象存储核心操作接口，定义统一规范）|
|具体产品（Concrete Product）|`MinioStorage`、`ObsStorage`、`OssStorage`（三种存储的具体实现）|
|抽象工厂（Abstract Factory）|`ObjectStorageFactory`（对象存储工厂接口，定义创建存储实例的方法）|
|具体工厂（Concrete Factory）|`MinioStorageFactory`、`ObsStorageFactory`、`OssStorageFactory`（对应三种存储的工厂实现）|
|配置驱动|配置文件（properties/yaml）+ 反射/工厂管理器，实现动态切换|
### 2. 核心分层（高内聚低耦合）

1. **API层**：定义统一的对象存储操作接口（抽象产品），屏蔽不同存储的实现差异。

2. **实现层**：分别实现MinIO、OBS、OSS的具体操作（具体产品），依赖各自的SDK。

3. **工厂层**：通过抽象工厂和具体工厂，封装具体存储实例的创建逻辑。

4. **配置层**：通过配置文件指定存储类型，动态创建对应工厂和存储实例。

5. **客户端层**：依赖抽象接口和工厂，无需感知具体存储实现，实现无缝切换。

## 二、完整代码实现

### 步骤1：定义抽象产品（统一对象存储接口）

首先定义所有对象存储都需实现的核心操作接口（上传、下载、删除、获取文件URL），作为抽象产品，保证客户端调用的统一性。

```java

import java.io.InputStream;

/**
 * 抽象产品：对象存储核心操作接口（统一所有存储的操作规范）
 */
public interface ObjectStorage {
    /**
     * 文件上传
     * @param bucketName 存储桶名称
     * @param objectKey 文件唯一标识（如：test/abc.jpg）
     * @param inputStream 文件输入流
     * @param fileSize 文件大小
     * @param contentType 文件类型（如：image/jpeg）
     * @return 上传是否成功
     */
    boolean uploadFile(String bucketName, String objectKey, InputStream inputStream, long fileSize, String contentType);

    /**
     * 文件下载
     * @param bucketName 存储桶名称
     * @param objectKey 文件唯一标识
     * @return 文件输入流
     */
    InputStream downloadFile(String bucketName, String objectKey);

    /**
     * 文件删除
     * @param bucketName 存储桶名称
     * @param objectKey 文件唯一标识
     * @return 删除是否成功
     */
    boolean deleteFile(String bucketName, String objectKey);

    /**
     * 获取文件访问URL
     * @param bucketName 存储桶名称
     * @param objectKey 文件唯一标识
     * @param expireSeconds 过期时间（秒）
     * @return 文件访问URL
     */
    String getFileAccessUrl(String bucketName, String objectKey, long expireSeconds);
}
```

### 步骤2：实现具体产品（三种存储的具体实现）

分别实现MinIO、OBS、OSS的具体操作，依赖各自的SDK（需自行引入对应依赖）。

#### 2.1 MinIO 具体产品实现

```java

import io.minio.MinioClient;
import io.minio.UploadObjectArgs;
import java.io.InputStream;

/**
 * 具体产品：MinIO对象存储实现
 */
public class MinioStorage implements ObjectStorage {
    // MinIO客户端（由工厂传入配置初始化）
    private MinioClient minioClient;

    // 构造方法：接收初始化后的MinIO客户端
    public MinioStorage(MinioClient minioClient) {
        this.minioClient = minioClient;
    }

    @Override
    public boolean uploadFile(String bucketName, String objectKey, InputStream inputStream, long fileSize, String contentType) {
        try {
            // 上传逻辑（MinIO SDK 操作）
            minioClient.uploadObject(
                    UploadObjectArgs.builder()
                            .bucket(bucketName)
                            .object(objectKey)
                            .stream(inputStream, fileSize, -1)
                            .contentType(contentType)
                            .build()
            );
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public InputStream downloadFile(String bucketName, String objectKey) {
        try {
            // 下载逻辑（MinIO SDK 操作）
            return minioClient.getObject(
                    io.minio.GetObjectArgs.builder()
                            .bucket(bucketName)
                            .object(objectKey)
                            .build()
            );
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public boolean deleteFile(String bucketName, String objectKey) {
        try {
            // 删除逻辑（MinIO SDK 操作）
            minioClient.removeObject(
                    io.minio.RemoveObjectArgs.builder()
                            .bucket(bucketName)
                            .object(objectKey)
                            .build()
            );
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public String getFileAccessUrl(String bucketName, String objectKey, long expireSeconds) {
        try {
            // 获取预签名URL（MinIO SDK 操作）
            return minioClient.getPresignedObjectUrl(
                    io.minio.GetPresignedObjectUrlArgs.builder()
                            .bucket(bucketName)
                            .object(objectKey)
                            .expiry((int) expireSeconds)
                            .build()
            );
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

#### 2.2 华为OBS 具体产品实现

```java

import com.obs.services.ObsClient;
import com.obs.services.model.ObsObject;
import java.io.InputStream;

/**
 * 具体产品：华为OBS对象存储实现
 */
public class ObsStorage implements ObjectStorage {
    // OBS客户端（由工厂传入配置初始化）
    private ObsClient obsClient;

    // 构造方法：接收初始化后的OBS客户端
    public ObsStorage(ObsClient obsClient) {
        this.obsClient = obsClient;
    }

    @Override
    public boolean uploadFile(String bucketName, String objectKey, InputStream inputStream, long fileSize, String contentType) {
        try {
            // OBS上传逻辑
            obsClient.putObject(bucketName, objectKey, inputStream, fileSize, contentType, null);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public InputStream downloadFile(String bucketName, String objectKey) {
        try {
            // OBS下载逻辑
            ObsObject obsObject = obsClient.getObject(bucketName, objectKey);
            return obsObject.getObjectContent();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public boolean deleteFile(String bucketName, String objectKey) {
        try {
            // OBS删除逻辑
            obsClient.deleteObject(bucketName, objectKey);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public String getFileAccessUrl(String bucketName, String objectKey, long expireSeconds) {
        try {
            // OBS获取预签名URL逻辑
            return obsClient.createSignedUrl(bucketName, objectKey, expireSeconds * 1000, null).getSignedUrl();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

#### 2.3 阿里云OSS 具体产品实现

```java

import com.aliyun.oss.OSS;
import com.aliyun.oss.model.OSSObject;
import java.io.InputStream;
import java.util.Date;

/**
 * 具体产品：阿里云OSS对象存储实现
 */
public class OssStorage implements ObjectStorage {
    // OSS客户端（由工厂传入配置初始化）
    private OSS ossClient;

    // 构造方法：接收初始化后的OSS客户端
    public OssStorage(OSS ossClient) {
        this.ossClient = ossClient;
    }

    @Override
    public boolean uploadFile(String bucketName, String objectKey, InputStream inputStream, long fileSize, String contentType) {
        try {
            // OSS上传逻辑
            ossClient.putObject(bucketName, objectKey, inputStream);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public InputStream downloadFile(String bucketName, String objectKey) {
        try {
            // OSS下载逻辑
            OSSObject ossObject = ossClient.getObject(bucketName, objectKey);
            return ossObject.getObjectContent();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @Override
    public boolean deleteFile(String bucketName, String objectKey) {
        try {
            // OSS删除逻辑
            ossClient.deleteObject(bucketName, objectKey);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public String getFileAccessUrl(String bucketName, String objectKey, long expireSeconds) {
        try {
            // OSS获取预签名URL逻辑
            Date expiration = new Date(System.currentTimeMillis() + expireSeconds * 1000);
            return ossClient.generatePresignedUrl(bucketName, objectKey, expiration).toString();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

### 步骤3：定义抽象工厂（对象存储工厂接口）

抽象工厂只定义创建`ObjectStorage`实例的统一方法，不涉及具体存储的创建细节，为具体工厂提供规范。

```java

/**
 * 抽象工厂：对象存储工厂接口
 */
public interface ObjectStorageFactory {
    /**
     * 创建对象存储实例
     * @return 统一的ObjectStorage接口实现
     */
    ObjectStorage createObjectStorage();
}
```

### 步骤4：实现具体工厂（对应三种存储）

具体工厂负责初始化对应存储的客户端（读取配置），并创建具体的`ObjectStorage`实例，每个工厂对应一个存储产品族。

#### 4.1 MinIO 具体工厂

```java

import io.minio.MinioClient;
import java.util.Properties;

/**
 * 具体工厂：MinIO对象存储工厂
 */
public class MinioStorageFactory implements ObjectStorageFactory {
    // 读取MinIO配置（可从配置文件/环境变量中获取）
    private String endpoint;
    private String accessKey;
    private String secretKey;

    // 构造方法：初始化配置（实际项目中可通过Spring注入/配置工具类读取）
    public MinioStorageFactory() {
        loadConfig();
    }

    // 加载MinIO配置文件
    private void loadConfig() {
        try {
            Properties props = new Properties();
            // 读取object-storage.properties配置文件
            props.load(MinioStorageFactory.class.getClassLoader().getResourceAsStream("object-storage.properties"));
            this.endpoint = props.getProperty("minio.endpoint");
            this.accessKey = props.getProperty("minio.accessKey");
            this.secretKey = props.getProperty("minio.secretKey");
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("加载MinIO配置失败");
        }
    }

    @Override
    public ObjectStorage createObjectStorage() {
        // 初始化MinIO客户端
        MinioClient minioClient = MinioClient.builder()
                .endpoint(endpoint)
                .credentials(accessKey, secretKey)
                .build();
        // 创建并返回MinIO存储实例
        return new MinioStorage(minioClient);
    }
}
```

#### 4.2 华为OBS 具体工厂

```java

import com.obs.services.ObsClient;
import java.util.Properties;

/**
 * 具体工厂：华为OBS对象存储工厂
 */
public class ObsStorageFactory implements ObjectStorageFactory {
    // OBS配置项
    private String endpoint;
    private String accessKey;
    private String secretKey;

    public ObsStorageFactory() {
        loadConfig();
    }

    // 加载OBS配置
    private void loadConfig() {
        try {
            Properties props = new Properties();
            props.load(ObsStorageFactory.class.getClassLoader().getResourceAsStream("object-storage.properties"));
            this.endpoint = props.getProperty("obs.endpoint");
            this.accessKey = props.getProperty("obs.accessKey");
            this.secretKey = props.getProperty("obs.secretKey");
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("加载OBS配置失败");
        }
    }

    @Override
    public ObjectStorage createObjectStorage() {
        // 初始化OBS客户端
        ObsClient obsClient = new ObsClient(accessKey, secretKey, endpoint);
        // 创建并返回OBS存储实例
        return new ObsStorage(obsClient);
    }
}
```

#### 4.3 阿里云OSS 具体工厂

```java

import com.aliyun.oss.OSS;
import com.aliyun.oss.OSSClientBuilder;
import java.util.Properties;

/**
 * 具体工厂：阿里云OSS对象存储工厂
 */
public class OssStorageFactory implements ObjectStorageFactory {
    // OSS配置项
    private String endpoint;
    private String accessKeyId;
    private String accessKeySecret;

    public OssStorageFactory() {
        loadConfig();
    }

    // 加载OSS配置
    private void loadConfig() {
        try {
            Properties props = new Properties();
            props.load(OssStorageFactory.class.getClassLoader().getResourceAsStream("object-storage.properties"));
            this.endpoint = props.getProperty("oss.endpoint");
            this.accessKeyId = props.getProperty("oss.accessKeyId");
            this.accessKeySecret = props.getProperty("oss.accessKeySecret");
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("加载OSS配置失败");
        }
    }

    @Override
    public ObjectStorage createObjectStorage() {
        // 初始化OSS客户端
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
        // 创建并返回OSS存储实例
        return new OssStorage(ossClient);
    }
}
```

### 步骤5：配置文件（指定存储类型）

创建`object-storage.properties`配置文件，放在`resources`目录下，通过`storage.type`指定当前使用的存储类型（minio/obs/oss），无需修改代码即可切换。

```properties

# 对象存储类型配置：minio / obs / oss
storage.type=minio

# MinIO配置
minio.endpoint=http://127.0.0.1:9000
minio.accessKey=minioadmin
minio.secretKey=minioadmin

# 华为OBS配置
obs.endpoint=https://your-obs-endpoint.obs.cn-north-1.myhuaweicloud.com
obs.accessKey=your-obs-access-key
obs.secretKey=your-obs-secret-key

# 阿里云OSS配置
oss.endpoint=https://your-oss-endpoint.oss-cn-beijing.aliyuncs.com
oss.accessKeyId=your-oss-access-key-id
oss.accessKeySecret=your-oss-access-key-secret
```

### 步骤6：工厂管理器（动态创建工厂，核心切换逻辑）

创建工厂管理器，负责读取配置文件中的存储类型，通过**反射**动态创建对应的具体工厂，实现“零代码修改”切换存储方式。

```java

import java.util.Properties;

/**
 * 对象存储工厂管理器：动态创建具体工厂，实现配置驱动切换
 */
public class ObjectStorageFactoryManager {
    // 单例管理器（避免重复读取配置）
    private static final ObjectStorageFactoryManager INSTANCE = new ObjectStorageFactoryManager();
    // 存储类型（从配置文件读取）
    private String storageType;
    // 配置文件路径
    private static final String CONFIG_FILE = "object-storage.properties";

    // 私有构造方法，初始化时读取配置
    private ObjectStorageFactoryManager() {
        loadStorageType();
    }

    // 获取管理器单例
    public static ObjectStorageFactoryManager getInstance() {
        return INSTANCE;
    }

    // 读取配置文件中的存储类型
    private void loadStorageType() {
        try {
            Properties props = new Properties();
            props.load(ObjectStorageFactoryManager.class.getClassLoader().getResourceAsStream(CONFIG_FILE));
            this.storageType = props.getProperty("storage.type").trim().toLowerCase();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("读取对象存储配置文件失败");
        }
    }

    /**
     * 动态创建具体的对象存储工厂
     * @return 抽象工厂实例
     */
    public ObjectStorageFactory createFactory() {
        // 根据存储类型，通过反射创建对应工厂
        switch (storageType) {
            case "minio":
                return new MinioStorageFactory();
            case "obs":
                return new ObsStorageFactory();
            case "oss":
                return new OssStorageFactory();
            default:
                throw new RuntimeException("不支持的对象存储类型：" + storageType + "，请检查配置文件");
        }

        // 进阶方案：完全反射（无需switch，新增存储类型时无需修改此方法）
        // try {
        //     Properties props = new Properties();
        //     props.load(getClass().getClassLoader().getResourceAsStream(CONFIG_FILE));
        //     // 配置文件中指定工厂类名：minio.factory.class=com.example.MinioStorageFactory
        //     String factoryClassName = props.getProperty(storageType + ".factory.class");
        //     return (ObjectStorageFactory) Class.forName(factoryClassName).newInstance();
        // } catch (Exception e) {
        //     throw new RuntimeException("创建对象存储工厂失败", e);
        // }
    }

    /**
     * 快速获取对象存储实例（简化客户端调用）
     * @return ObjectStorage实例
     */
    public ObjectStorage getObjectStorage() {
        ObjectStorageFactory factory = createFactory();
        return factory.createObjectStorage();
    }
}
```

### 步骤7：客户端使用（简洁调用，无需感知具体存储）

客户端只需通过工厂管理器获取`ObjectStorage`实例，调用统一接口即可，无需关心底层是MinIO/OBS/OSS，切换存储仅需修改配置文件。

```java

import java.io.ByteArrayInputStream;
import java.io.InputStream;

/**
 * 客户端：使用对象存储服务
 */
public class ObjectStorageClient {
    public static void main(String[] args) {
        // 1. 通过工厂管理器获取对象存储实例（无需关心具体类型）
        ObjectStorage objectStorage = ObjectStorageFactoryManager.getInstance().getObjectStorage();

        // 2. 统一调用接口，操作对象存储
        String bucketName = "test-bucket";
        String objectKey = "test/hello.txt";
        String content = "Hello, Object Storage!";
        InputStream inputStream = new ByteArrayInputStream(content.getBytes());
        long fileSize = content.getBytes().length;
        String contentType = "text/plain";

        // 上传文件
        boolean uploadSuccess = objectStorage.uploadFile(bucketName, objectKey, inputStream, fileSize, contentType);
        System.out.println("文件上传是否成功：" + uploadSuccess);

        // 获取文件访问URL（过期时间3600秒）
        String fileUrl = objectStorage.getFileAccessUrl(bucketName, objectKey, 3600);
        System.out.println("文件访问URL：" + fileUrl);

        // 下载文件
        InputStream downloadStream = objectStorage.downloadFile(bucketName, objectKey);
        System.out.println("文件下载是否成功：" + (downloadStream != null));

        // 删除文件
        boolean deleteSuccess = objectStorage.deleteFile(bucketName, objectKey);
        System.out.println("文件删除是否成功：" + deleteSuccess);
    }
}
```

## 三、关键特性与扩展说明

### 1. 核心优势

- **配置驱动切换**：仅修改`object-storage.properties`中的`storage.type`，即可在MinIO/OBS/OSS之间无缝切换，无需改动业务代码。

- **统一接口调用**：客户端依赖`ObjectStorage`抽象接口，屏蔽了不同存储的SDK差异，降低耦合度。

- **易于扩展**：新增其他对象存储（如腾讯云COS）时，只需：
        

    1. 实现`ObjectStorage`接口（具体产品）；

    2. 实现`ObjectStorageFactory`接口（具体工厂）；

    3. 在配置文件中添加COS配置和存储类型，无需修改原有代码（符合开闭原则）。

- **职责清晰**：分层设计明确，API层、实现层、工厂层、配置层各司其职，便于维护。

### 2. 实际项目优化建议

- **依赖注入**：在Spring Boot/Spring Cloud项目中，可将工厂和存储实例注册为Spring Bean，通过`@Autowired`注入，替代手动单例管理。

- **配置优化**：使用Spring Boot的`application.yml`替代`properties`文件，通过`@ConfigurationProperties`注解自动绑定配置，更贴合Spring生态。

- **客户端池化**：MinIO/OBS/OSS的客户端建议使用池化技术（如Apache Commons Pool），避免频繁创建/销毁客户端，提升性能。

- **异常处理**：封装统一的对象存储异常（如`ObjectStorageException`），替换各SDK的原生异常，便于全局异常处理。

- **功能扩展**：可在`ObjectStorage`接口中新增更多功能（如批量上传/删除、存储桶创建/删除、文件大小查询等），保持接口统一性。

### 3. 适用场景

- 多环境部署（开发环境用MinIO，生产环境用OSS/OBS）；

- 多云架构（根据业务需求切换不同云厂商的对象存储）；

- 统一存储接入（业务系统无需关注底层存储实现，降低迁移成本）。

## 总结

本方案基于**抽象工厂模式**实现了MinIO、OBS、OSS三种对象存储的统一接入和动态切换，核心要点如下：

1. 以`ObjectStorage`为抽象产品，定义统一操作接口；

2. 以三种存储的实现类为具体产品，封装各自SDK操作；

3. 以`ObjectStorageFactory`为抽象工厂，`XXXStorageFactory`为具体工厂，封装实例创建逻辑；

4. 以配置文件+工厂管理器为驱动，通过反射实现动态切换；

5. 客户端依赖抽象接口，实现“配置修改即切换”，高内聚低耦合，易于扩展和维护。
> （注：文档部分内容可能由 AI 生成）