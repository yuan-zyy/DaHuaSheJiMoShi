# 对象存储动态切换设计模式解析与实现

除了简单工厂模式外，能实现对象存储动态切换的其他设计模式，核心有**工厂方法模式**、**抽象工厂模式**、**单例模式（配合依赖注入）**，此外还可以结合**依赖注入（Spring）**实现更优雅的动态切换，以下是每种方案的详细说明、代码实现及适用场景：

### 一、工厂方法模式（Factory Method Pattern）

#### 1. 模式核心思想

工厂方法模式是简单工厂模式的延伸，它摒弃了简单工厂的“单一工厂类创建所有产品”的设计，而是为**每一种产品（对象存储实现）都创建一个对应的工厂类**，同时定义一个统一的“工厂接口”，由具体工厂类负责创建对应产品实例，最终通过接口实现产品的动态切换。

#### 2. 核心角色

- 产品接口：`ObjectStorage`（统一对象存储操作）

- 具体产品：`MinioObjectStorage`、`OssObjectStorage`、`ObsObjectStorage`（已有实现，无需修改）

- 工厂接口：定义创建产品的统一方法

- 具体工厂：每种存储对应一个工厂，负责创建自身产品实例

#### 3. 代码实现

##### （1）定义工厂接口

```java

/**
 * 对象存储工厂接口（工厂方法模式核心）
 * 每个具体存储对应一个具体工厂，实现该接口
 */
public interface ObjectStorageFactory {
    /**
     * 创建对应对象存储实例
     * @return ObjectStorage 产品实例
     */
    ObjectStorage createObjectStorage();
}
```

##### （2）实现具体工厂类

```java

// MinIO 对应的具体工厂
public class MinioStorageFactory implements ObjectStorageFactory {
    // MinIO 配置参数（可从配置文件读取，此处简化为硬编码，实际可通过构造方法注入）
    private String endpoint = "http://127.0.0.1:9000";
    private String accessKey = "minioadmin";
    private String secretKey = "minioadmin";

    @Override
    public ObjectStorage createObjectStorage() {
        // 初始化 MinIO 客户端并创建产品实例
        MinioClient minioClient = MinioClient.builder()
                .endpoint(endpoint)
                .credentials(accessKey, secretKey)
                .build();
        return new MinioObjectStorage(minioClient);
    }
}

// OSS 对应的具体工厂
public class OssStorageFactory implements ObjectStorageFactory {
    private String endpoint = "oss-cn-beijing.aliyuncs.com";
    private String accessKeyId = "your-aliyun-access-key";
    private String accessKeySecret = "your-aliyun-secret";

    @Override
    public ObjectStorage createObjectStorage() {
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
        return new OssObjectStorage(ossClient);
    }
}

// OBS 对应的具体工厂
public class ObsStorageFactory implements ObjectStorageFactory {
    private String endpoint = "obs.cn-north-1.myhuaweicloud.com";
    private String accessKey = "your-huawei-access-key";
    private String secretKey = "your-huawei-secret-key";

    @Override
    public ObjectStorage createObjectStorage() {
        ObsClient obsClient = new ObsClient(accessKey, secretKey, endpoint);
        return new ObsObjectStorage(obsClient);
    }
}
```

##### （3）动态切换使用

```java

/**
 * 业务层使用：通过工厂接口动态切换存储类型
 */
public class BizService {
    public void useObjectStorage(String storageType) {
        // 1. 根据配置（storageType）创建对应工厂实例（动态切换核心）
        ObjectStorageFactory factory;
        switch (storageType.toLowerCase()) {
            case "minio":
                factory = new MinioStorageFactory();
                break;
            case "oss":
                factory = new OssStorageFactory();
                break;
            case "obs":
                factory = new ObsStorageFactory();
                break;
            default:
                throw new IllegalArgumentException("不支持的存储类型：" + storageType);
        }

        // 2. 通过工厂创建产品实例，调用统一接口
        ObjectStorage storage = factory.createObjectStorage();
        // 后续操作与之前一致，无需感知底层实现
        storage.uploadFile("bucket", "test.txt", null, 0, "text/plain");
    }
}
```

#### 4. 优势与适用场景

- 优势：符合“开闭原则”，新增存储类型（如腾讯云COS）时，只需新增“具体产品类”+“具体工厂类”，无需修改现有工厂和业务代码；职责单一，每个工厂只负责创建对应产品，便于维护。

- 适用场景：产品类型较多且需要频繁扩展的场景，比简单工厂模式更灵活、更易扩展。

### 二、抽象工厂模式（Abstract Factory Pattern）

#### 1. 模式核心思想

抽象工厂模式是工厂方法模式的进一步扩展，它适用于**产品存在“产品族”**的场景。对于对象存储场景，我们可以将“对象存储核心操作（上传/下载）”、“存储桶管理（创建/删除桶）”、“文件权限管理”等归为一个“对象存储产品族”，抽象工厂模式会定义一个统一的工厂接口，用于创建整个产品族的所有产品，具体工厂类对应具体产品族，从而实现整个产品族的动态切换。

#### 2. 核心角色（针对对象存储场景）

- 产品族1（核心存储操作）：接口 `ObjectStorage` + 具体产品 `Minio/Oss/ObsObjectStorage`

- 产品族2（存储桶管理）：接口 `BucketManager` + 具体产品 `Minio/Oss/ObsBucketManager`

- 抽象工厂接口：定义创建所有产品族的统一方法

- 具体工厂接口：每种存储对应一个具体工厂，负责创建自身产品族的所有产品

#### 3. 代码实现（简化版）

##### （1）定义第二个产品接口（存储桶管理，构成产品族）

```java

/**
 * 存储桶管理接口（产品族成员2）
 */
public interface BucketManager {
    boolean createBucket(String bucketName);
    boolean deleteBucket(String bucketName);
    boolean isBucketExist(String bucketName);
}

// MinIO 存储桶管理实现
public class MinioBucketManager implements BucketManager {
    private MinioClient minioClient;

    public MinioBucketManager(MinioClient minioClient) {
        this.minioClient = minioClient;
    }

    @Override
    public boolean createBucket(String bucketName) {
        try {
            minioClient.makeBucket(io.minio.MakeBucketArgs.builder().bucket(bucketName).build());
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    // 其他方法（deleteBucket/isBucketExist）实现省略...
}
```

##### （2）定义抽象工厂接口（创建产品族）

```java

/**
 * 抽象工厂接口：创建对象存储产品族的所有产品
 */
public interface ObjectStorageAbstractFactory {
    // 创建核心存储操作产品
    ObjectStorage createObjectStorage();
    // 创建存储桶管理产品
    BucketManager createBucketManager();
}
```

##### （3）实现具体抽象工厂

```java

// MinIO 抽象工厂（创建 MinIO 产品族的所有产品）
public class MinioAbstractFactory implements ObjectStorageAbstractFactory {
    private String endpoint = "http://127.0.0.1:9000";
    private String accessKey = "minioadmin";
    private String secretKey = "minioadmin";

    @Override
    public ObjectStorage createObjectStorage() {
        MinioClient minioClient = MinioClient.builder()
                .endpoint(endpoint)
                .credentials(accessKey, secretKey)
                .build();
        return new MinioObjectStorage(minioClient);
    }

    @Override
    public BucketManager createBucketManager() {
        MinioClient minioClient = MinioClient.builder()
                .endpoint(endpoint)
                .credentials(accessKey, secretKey)
                .build();
        return new MinioBucketManager(minioClient);
    }
}

// OSS 抽象工厂（省略，结构与 MinioAbstractFactory 一致）
public class OssAbstractFactory implements ObjectStorageAbstractFactory {
    // 实现 createObjectStorage 和 createBucketManager 方法...
}
```

##### （4）动态切换使用

```java

public class BizService {
    public void useStorageProductFamily(String storageType) {
        // 1. 动态创建对应抽象工厂
        ObjectStorageAbstractFactory abstractFactory;
        switch (storageType.toLowerCase()) {
            case "minio":
                abstractFactory = new MinioAbstractFactory();
                break;
            case "oss":
                abstractFactory = new OssAbstractFactory();
                break;
            default:
                throw new IllegalArgumentException("不支持的存储类型");
        }

        // 2. 创建产品族的所有产品
        ObjectStorage storage = abstractFactory.createObjectStorage();
        BucketManager bucketManager = abstractFactory.createBucketManager();

        // 3. 使用产品
        bucketManager.createBucket("test-bucket");
        storage.uploadFile("test-bucket", "test.txt", null, 0, "text/plain");
    }
}
```

#### 4. 优势与适用场景

- 优势：支持整个产品族的动态切换，保证同一产品族内的产品兼容性（如 MinIO 的存储操作和桶管理必然是兼容的）；同样符合“开闭原则”。

- 适用场景：对象存储不仅需要核心文件操作，还需要配套的桶管理、权限管理等“产品族”功能时，优先使用抽象工厂模式。

### 三、单例模式 + 依赖注入（Spring 环境推荐）

#### 1. 核心思想

单例模式确保每种对象存储实例在应用中只有一个（避免重复创建客户端连接，节省资源），再结合 Spring 的**依赖注入（DI）和条件注解**，根据配置文件中的存储类型，动态注入对应的单例实例，实现无侵入式的动态切换。

#### 2. 关键技术（Spring Boot）

- `@Configuration`：配置类，用于创建存储实例

- `@Bean`：将实例注册为 Spring 单例 Bean

- `@ConditionalOnProperty`：根据配置文件中的属性值，条件化创建 Bean

- `@Autowired`：业务层注入 `ObjectStorage` 接口，Spring 自动注入对应实例

#### 3. 代码实现

##### （1）Spring 配置类（核心：条件化创建单例 Bean）

```java

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 对象存储配置类：通过条件注解实现动态切换，且所有实例为单例
 */
@Configuration
public class ObjectStorageConfig {

    // 当配置文件中 object.storage.type=minio 时，创建 MinIO 单例 Bean
    @Bean
    @ConditionalOnProperty(name = "object.storage.type", havingValue = "minio")
    public ObjectStorage minioObjectStorage() {
        MinioClient minioClient = MinioClient.builder()
                .endpoint("http://127.0.0.1:9000")
                .credentials("minioadmin", "minioadmin")
                .build();
        return new MinioObjectStorage(minioClient);
    }

    // 当配置文件中 object.storage.type=oss 时，创建 OSS 单例 Bean
    @Bean
    @ConditionalOnProperty(name = "object.storage.type", havingValue = "oss")
    public ObjectStorage ossObjectStorage() {
        OSS ossClient = new OSSClientBuilder().build(
                "oss-cn-beijing.aliyuncs.com",
                "your-aliyun-access-key",
                "your-aliyun-secret"
        );
        return new OssObjectStorage(ossClient);
    }

    // 当配置文件中 object.storage.type=obs 时，创建 OBS 单例 Bean
    @Bean
    @ConditionalOnProperty(name = "object.storage.type", havingValue = "obs")
    public ObjectStorage obsObjectStorage() {
        ObsClient obsClient = new ObsClient(
                "your-huawei-access-key",
                "your-huawei-secret-key",
                "obs.cn-north-1.myhuaweicloud.com"
        );
        return new ObsObjectStorage(obsClient);
    }
}
```

##### （2）业务层使用（无感知动态切换）

```java

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class BizService {
    // 直接注入 ObjectStorage 接口，Spring 自动注入对应配置的单例实例
    @Autowired
    private ObjectStorage objectStorage;

    public void uploadFile() {
        // 直接调用，无需关心底层实现，修改配置即可切换
        objectStorage.uploadFile("bucket", "test.txt", null, 0, "text/plain");
    }
}
```

#### 4. 优势与适用场景

- 优势：无侵入式切换（无需手动创建工厂/实例），由 Spring 管理单例生命周期，节省资源；代码极简，业务层只需注入接口即可使用。

- 适用场景：基于 Spring Boot/Spring Framework 的项目（绝大多数实际项目场景），优先使用该方案。

### 四、各模式对比与选型建议

|设计模式/方案|核心特点|优势|适用场景|
|---|---|---|---|
|简单工厂模式|单一工厂创建所有产品|实现简单、轻量，无需额外类|产品类型较少、扩展频率低的场景|
|工厂方法模式|一个产品对应一个工厂，工厂接口统一|符合开闭原则，扩展灵活，职责单一|产品类型较多、需要频繁扩展的场景|
|抽象工厂模式|一个工厂创建一个产品族|保证产品族兼容性，支持整体切换|存在配套产品族（如存储+桶管理）的场景|
|单例模式+Spring依赖注入|条件化创建单例Bean，自动注入|无侵入、极简、资源复用|Spring Boot/Spring 项目（实际项目首选）|
### 总结

1. 工厂方法模式：为每种存储创建独立工厂，扩展灵活，符合开闭原则，适用于多产品扩展场景；

2. 抽象工厂模式：针对“产品族”设计，支持整套功能的动态切换，适用于存储+配套功能（桶管理等）的场景；

3. 单例模式+Spring依赖注入：Spring 环境下最优解，无侵入、极简，自动管理单例生命周期，实际项目优先使用；

4. 核心共性：所有方案均基于“面向接口编程”，实现业务层与底层存储的解耦，达到动态切换的目的。
> （注：文档部分内容可能由 AI 生成）