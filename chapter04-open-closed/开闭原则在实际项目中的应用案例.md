# 开闭原则在实际项目中的应用案例

开闭原则（Open/Closed Principle, OCP）的核心思想是“对扩展开放，对修改关闭”。在实际Java项目中，通过抽象隔离变化、结合设计模式（策略模式、装饰器模式等）可有效落地该原则。以下是5个高频且贴近真实开发的应用案例，均遵循“新增功能仅扩展代码，不修改原有稳定逻辑”的核心要求。

# 一、电商订单优惠计算（策略模式落地）

## 场景描述

电商系统初始仅支持“满200减50”的满减优惠，后续需迭代新增“8折折扣”“优惠券抵扣”“会员额外减10元”等优惠规则，要求不修改核心订单计算逻辑。

## 反例（违反开闭原则）

新增优惠规则需修改核心计算方法，频繁改动易引入bug：

```java

// 订单服务类（核心逻辑）
public class OrderService {
    // 计算最终价格：新增优惠需修改此方法
    public double calculateFinalPrice(double originalPrice, String discountType) {
        if ("full_reduce".equals(discountType)) {
            return originalPrice >= 200 ? originalPrice - 50 : originalPrice;
        }
        // 新增折扣优惠，必须修改原有方法
        else if ("discount".equals(discountType)) {
            return originalPrice * 0.8;
        }
        return originalPrice;
    }
}
```

## 合规实现（遵循开闭原则）

通过抽象优惠策略接口，新增规则仅扩展实现类，核心逻辑对修改关闭：

```java

// 1. 定义优惠策略接口（抽象隔离变化）
public interface DiscountStrategy {
    double calculate(double originalPrice);
}

// 2. 原有满减策略（无需修改）
public class FullReduceStrategy implements DiscountStrategy {
    @Override
    public double calculate(double originalPrice) {
        return originalPrice >= 200 ? originalPrice - 50 : originalPrice;
    }
}

// 3. 新增折扣策略（仅扩展，不修改原有代码）
public class DiscountStrategyImpl implements DiscountStrategy {
    @Override
    public double calculate(double originalPrice) {
        return originalPrice * 0.8;
    }
}

// 4. 新增会员优惠策略（继续扩展）
public class MemberDiscountStrategy implements DiscountStrategy {
    @Override
    public double calculate(double originalPrice) {
        // 叠加满减后再减10元
        return new FullReduceStrategy().calculate(originalPrice) - 10;
    }
}

// 5. 订单服务类（对修改关闭）
public class OrderService {
    // 依赖抽象接口，而非具体实现
    public double calculateFinalPrice(double originalPrice, DiscountStrategy strategy) {
        return strategy.calculate(originalPrice);
    }
}

// 调用示例
public class Test {
    public static void main(String[] args) {
        OrderService orderService = new OrderService();
        // 原有满减逻辑
        double price1 = orderService.calculateFinalPrice(200, new FullReduceStrategy());
        // 新增折扣逻辑（无修改OrderService）
        double price2 = orderService.calculateFinalPrice(200, new DiscountStrategyImpl());
    }
}
```

## 落地价值

新增任何优惠规则只需扩展`DiscountStrategy`实现类，核心`OrderService`代码零修改，避免回归测试风险，提升迭代效率。

# 二、日志功能扩展（装饰器模式落地）

## 场景描述

系统初始仅支持“控制台输出日志”，后续需新增“日志写入文件”“日志脱敏（隐藏手机号/身份证）”“日志同步到ELK”等功能，要求自由组合扩展功能且不修改基础日志逻辑。

## 合规实现（遵循开闭原则）

通过装饰器模式包装基础日志对象，新增功能仅扩展装饰器类：

```java

// 1. 日志核心接口
public interface Logger {
    void log(String message);
}

// 2. 基础控制台日志（原有逻辑，无需修改）
public class ConsoleLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("控制台日志：" + message);
    }
}

// 3. 装饰器：文件日志扩展
public class FileLoggerDecorator implements Logger {
    private Logger logger; // 包装原有日志对象
    public FileLoggerDecorator(Logger logger) {
        this.logger = logger;
    }
    @Override
    public void log(String message) {
        logger.log(message); // 保留原有控制台输出
        // 新增文件写入逻辑
        try {
            java.nio.file.Files.write(java.nio.file.Paths.get("app.log"), (message + "\n").getBytes());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

// 4. 装饰器：日志脱敏扩展（继续扩展）
public class DesensitizeLoggerDecorator implements Logger {
    private Logger logger;
    public DesensitizeLoggerDecorator(Logger logger) {
        this.logger = logger;
    }
    @Override
    public void log(String message) {
        // 新增脱敏逻辑：替换手机号中间4位
        String desensitizedMsg = message.replaceAll("(1\\d{2})\\d{4}(\\d{4})", "$1****$2");
        logger.log(desensitizedMsg); // 调用包装的日志对象
    }
}

// 调用示例：组合多个扩展功能
public class Test {
    public static void main(String[] args) {
        // 控制台+文件+脱敏：仅组合装饰器，无修改原有类
        Logger logger = new DesensitizeLoggerDecorator(new FileLoggerDecorator(new ConsoleLogger()));
        logger.log("用户手机号：13812345678");
    }
}
```

## 落地价值

新增日志功能只需添加装饰器类，基础`ConsoleLogger`永久无需修改；支持多功能自由组合（如“控制台+脱敏”“文件+ELK”），灵活性极高。

# 三、支付渠道对接（Spring+策略模式落地）

## 场景描述

电商系统初始仅对接支付宝，后续需接入微信支付、银联支付、Apple Pay，要求新增支付渠道时不修改支付调度逻辑，且适配Spring框架的依赖注入特性。

## 合规实现（遵循开闭原则）

通过支付接口定义标准，Spring自动注入所有实现类，调度逻辑对修改关闭：

```java

// 1. 支付接口
public interface PaymentService {
    String pay(String orderId, double amount);
    String getPayType(); // 标识支付类型（如alipay、wxpay）
}

// 2. 原有支付宝实现（无需修改）
@Service
public class AliPayService implements PaymentService {
    @Override
    public String pay(String orderId, double amount) {
        return "支付宝支付成功，订单号：" + orderId + "，金额：" + amount;
    }
    @Override
    public String getPayType() {
        return "alipay";
    }
}

// 3. 新增微信支付实现（仅扩展）
@Service
public class WxPayService implements PaymentService {
    @Override
    public String pay(String orderId, double amount) {
        return "微信支付成功，订单号：" + orderId + "，金额：" + amount;
    }
    @Override
    public String getPayType() {
        return "wxpay";
    }
}

// 4. 支付调度类（对修改关闭）
@Service
public class PaymentDispatcher {
    // Spring自动注入所有PaymentService实现类
    @Autowired
    private List<PaymentService> paymentServices;

    // 调度支付：新增渠道无需修改此方法
    public String dispatchPay(String payType, String orderId, double amount) {
        for (PaymentService service : paymentServices) {
            if (service.getPayType().equals(payType)) {
                return service.pay(orderId, amount);
            }
        }
        throw new IllegalArgumentException("不支持的支付类型");
    }
}

// 调用示例
@RestController
public class PaymentController {
    @Autowired
    private PaymentDispatcher dispatcher;

    @PostMapping("/pay")
    public String pay(@RequestParam String payType, @RequestParam String orderId, @RequestParam double amount) {
        return dispatcher.dispatchPay(payType, orderId, amount);
    }
}
```

## 落地价值

新增Apple Pay、银联支付只需编写对应`PaymentService`实现类并添加`@Service`注解，支付调度类`PaymentDispatcher`和控制器零修改，完全符合开闭原则，适配企业级Spring项目开发规范。

# 四、接口版本兼容（适配器模式落地）

## 场景描述

系统对外提供的用户查询接口`/api/v1/user`（返回id、name）需迭代升级，新增`/api/v2/user`接口（新增age、phone字段），要求兼容旧版本v1，且不修改v1接口的核心逻辑。

## 合规实现（遵循开闭原则）

通过定义统一目标接口，不同版本实现类独立扩展，适配器负责版本路由：

```java

// 1. 目标接口（统一标准）
public interface UserApi {
    Map<String, Object> getUser(String userId);
}

// 2. v1版本实现（原有逻辑，无需修改）
public class UserApiV1 implements UserApi {
    @Override
    public Map<String, Object> getUser(String userId) {
        Map<String, Object> user = new HashMap<>();
        user.put("id", userId);
        user.put("name", "张三");
        return user;
    }
}

// 3. v2版本实现（扩展）
public class UserApiV2 implements UserApi {
    @Override
    public Map<String, Object> getUser(String userId) {
        Map<String, Object> user = new HashMap<>();
        user.put("id", userId);
        user.put("name", "张三");
        user.put("age", 25);
        user.put("phone", "13812345678");
        return user;
    }
}

// 4. 适配器（路由不同版本）
public class UserApiAdapter {
    // 根据版本号选择实现类，新增版本只需加分支
    public Map<String, Object> getUser(String userId, String version) {
        UserApi userApi = "v1".equals(version) ? new UserApiV1() : new UserApiV2();
        return userApi.getUser(userId);
    }
}

// 调用示例
@RestController
@RequestMapping("/api")
public class UserController {
    @GetMapping("/{version}/user")
    public Map<String, Object> getUser(@PathVariable String version, @RequestParam String userId) {
        return new UserApiAdapter().getUser(userId, version);
    }
}
```

## 落地价值

新增v3、v4版本只需实现`UserApi`接口，适配器仅需添加一行版本路由分支，原有v1、v2接口代码零修改，保障老用户系统稳定运行。

# 五、数据缓存扩展（代理模式+Spring AOP落地）

## 场景描述

用户查询、商品查询等业务接口初始无缓存，后续需新增“本地缓存”“Redis缓存”提升性能，要求不修改业务核心逻辑，且缓存功能可灵活切换。

## 合规实现（遵循开闭原则）

通过Spring AOP实现代理功能，缓存逻辑封装在切面中，业务类零侵入：

```java

// 1. 自定义缓存注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Cacheable {
    String key() default ""; // 缓存key
}

// 2. 业务接口（原有逻辑，无需修改）
@Service
public class UserService {
    @Cacheable(key = "user_#userId") // 新增缓存注解，无修改方法体
    public String getUser(String userId) {
        // 模拟数据库查询（核心业务逻辑）
        System.out.println("查询数据库，用户ID：" + userId);
        return "用户" + userId + "的信息";
    }
}

// 3. AOP切面（扩展缓存功能，无修改业务类）
@Aspect
@Component
public class CacheAspect {
    private Map<String, String> localCache = new HashMap<>();

    // 拦截加了@Cacheable的方法
    @Around("@annotation(cacheable)")
    public Object around(ProceedingJoinPoint joinPoint, Cacheable cacheable) throws Throwable {
        // 解析缓存key
        String key = cacheable.key().replace("#userId", joinPoint.getArgs()[0].toString());
        // 缓存命中则直接返回
        if (localCache.containsKey(key)) {
            System.out.println("从缓存获取：" + key);
            return localCache.get(key);
        }
        // 未命中则执行原方法
        Object result = joinPoint.proceed();
        // 存入缓存
        localCache.put(key, result.toString());
        return result;
    }
}

// 调用示例
public class Test {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        UserService userService = context.getBean(UserService.class);
        
        userService.getUser("U1001"); // 第一次：查数据库+存缓存
        userService.getUser("U1001"); // 第二次：直接从缓存获取
    }
}
```

## 落地价值

切换为Redis缓存只需修改`CacheAspect`的缓存实现（替换localCache为Redis客户端），业务类`UserService`零修改；新增缓存功能只需扩展切面，符合开闭原则的“扩展开放”要求。

# 六、核心总结

1. **落地核心**：开闭原则的本质是“抽象隔离变化”，通过接口/抽象类定义稳定的核心逻辑，将易变逻辑封装在实现类中，实现“扩展开放、修改关闭”。

2. **工具适配**：不同场景对应不同设计模式——规则扩展用策略模式、功能增强用装饰器模式、接口兼容用适配器模式、横切功能用代理模式（Spring AOP）。

3. **项目价值**：遵循开闭原则可降低代码修改风险，减少回归测试成本，提升项目的可维护性和迭代效率，尤其适配中大型项目的长期迭代需求。
> （注：文档部分内容可能由 AI 生成）