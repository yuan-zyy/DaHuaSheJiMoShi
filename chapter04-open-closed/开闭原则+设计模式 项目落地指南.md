# 开闭原则+设计模式 项目落地指南

本文档整理了开闭原则在实际Java项目中的落地方案，通过“业务场景+设计模式”的组合方式，明确不同场景下的适配模式、实现思路及代码示例，助力快速落地开闭原则。

# 一、订单优惠/支付渠道扩展场景（适配：策略模式）

## 核心目标

新增优惠规则/支付渠道时，不修改核心的订单计算/支付调度逻辑，仅通过新增代码实现扩展。

## 实现思路

1. 定义统一的策略接口（如支付策略、优惠策略），包含核心业务方法；

2. 不同的规则/渠道分别实现该接口，封装各自的业务逻辑；

3. 核心调度类依赖策略接口而非具体实现，通过传入不同实现类切换逻辑。

## 极简Java示例

```java

// 1. 定义支付策略接口（核心抽象）
public interface PayStrategy {
    void pay(Order order); // 统一支付方法
}

// 2. 原有实现：支付宝支付（无需修改）
public class AliPayStrategy implements PayStrategy {
    @Override
    public void pay(Order order) {
        System.out.println("执行支付宝支付逻辑，订单号：" + order.getOrderId());
    }
}

// 3. 新增实现：微信支付（仅新增代码，无修改）
public class WxPayStrategy implements PayStrategy {
    @Override
    public void pay(Order order) {
        System.out.println("执行微信支付逻辑，订单号：" + order.getOrderId());
    }
}

// 4. 核心调度类（对修改关闭，永远无需改动）
public class PayContext {
    private PayStrategy strategy;

    // 通过构造器注入不同策略
    public PayContext(PayStrategy strategy) {
        this.strategy = strategy;
    }

    // 执行支付（逻辑固定）
    public void executePay(Order order) {
        strategy.pay(order);
    }
}

// 测试调用（新增渠道仅需new新的策略类）
public class Test {
    public static void main(String[] args) {
        Order order = new Order("O123456");
        // 支付宝支付（原有逻辑）
        new PayContext(new AliPayStrategy()).executePay(order);
        // 微信支付（新增逻辑，无修改原有代码）
        new PayContext(new WxPayStrategy()).executePay(order);
    }
}

// 简化的Order类
class Order {
    private String orderId;
    public Order(String orderId) { this.orderId = orderId; }
    public String getOrderId() { return orderId; }
}
```

# 二、日志/IO功能增强场景（适配：装饰器模式）

## 核心目标

给基础功能新增增强逻辑（如日志加文件输出、IO加缓冲）时，不修改基础实现类，仅通过“包装”扩展功能。

## 实现思路

1. 定义组件核心接口（如日志接口、IO接口）；

2. 实现基础功能类（如控制台日志、基础IO流）；

3. 创建装饰器类，实现核心接口并包装基础类，在原有逻辑上新增增强功能；

4. 调用方通过组合不同装饰器，实现功能叠加。

## 极简Java示例

```java

// 1. 定义日志核心接口
public interface Logger {
    void log(String msg);
}

// 2. 基础实现：控制台日志（原有，无需修改）
public class ConsoleLogger implements Logger {
    @Override
    public void log(String msg) {
        System.out.println("控制台日志：" + msg);
    }
}

// 3. 装饰器：文件日志增强（仅新增代码）
public class FileLoggerDecorator implements Logger {
    private Logger logger; // 包装原有Logger对象

    public FileLoggerDecorator(Logger logger) {
        this.logger = logger;
    }

    @Override
    public void log(String msg) {
        // 保留原有控制台日志逻辑
        logger.log(msg);
        // 新增文件输出逻辑（扩展功能）
        try {
            java.nio.file.Files.write(
                java.nio.file.Paths.get("app.log"),
                (msg + "\n").getBytes(),
                java.nio.file.StandardOpenOption.APPEND,
                java.nio.file.StandardOpenOption.CREATE
            );
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

// 测试调用
public class Test {
    public static void main(String[] args) {
        // 原有逻辑：仅控制台日志
        Logger consoleLogger = new ConsoleLogger();
        consoleLogger.log("原有日志内容");

        // 扩展逻辑：控制台+文件日志（无修改原有类）
        Logger fileLogger = new FileLoggerDecorator(consoleLogger);
        fileLogger.log("新增日志内容（同时输出到文件）");
    }
}
```

# 三、商品/订单类型创建场景（适配：工厂模式）

## 核心目标

新增商品/订单类型时，不修改核心的对象创建逻辑，仅通过新增产品类或工厂分支实现扩展。

## 实现思路

1. 定义产品统一接口，封装不同类型的公共行为；

2. 不同类型的产品分别实现该接口；

3. 创建工厂类，根据类型参数返回对应的产品实例；

4. 新增产品时，仅需新增产品实现类，并在工厂中添加对应的创建分支（或新增工厂实现类）。

## 极简Java示例

```java

// 1. 定义产品接口
public interface Product {
    void create(); // 产品创建的公共方法
}

// 2. 原有产品：手机（无需修改）
public class PhoneProduct implements Product {
    @Override
    public void create() {
        System.out.println("创建手机产品");
    }
}

// 3. 新增产品：电脑（仅新增代码）
public class ComputerProduct implements Product {
    @Override
    public void create() {
        System.out.println("创建电脑产品");
    }
}

// 4. 工厂类（简单工厂，新增类型仅加分支）
public class ProductFactory {
    public static Product createProduct(String type) {
        if ("phone".equals(type)) {
            return new PhoneProduct(); // 原有分支
        } else if ("computer".equals(type)) {
            return new ComputerProduct(); // 新增分支，无其他修改
        }
        throw new IllegalArgumentException("不支持的产品类型");
    }
}

// 测试调用
public class Test {
    public static void main(String[] args) {
        // 原有逻辑：创建手机
        Product phone = ProductFactory.createProduct("phone");
        phone.create();

        // 扩展逻辑：创建电脑（无修改工厂核心逻辑）
        Product computer = ProductFactory.createProduct("computer");
        computer.create();
    }
}
```

# 四、接口版本兼容/第三方适配场景（适配：适配器模式）

## 核心目标

兼容新旧接口、异构第三方接口时，不修改项目内原有业务逻辑，仅通过适配器类做接口转换。

## 实现思路

1. 定义项目内统一的目标接口（符合业务规范）；

2. 确定需要适配的“适配者”（如旧接口、第三方接口，无法修改）；

3. 创建适配器类，实现目标接口，并包装适配者对象；

4. 在适配器中完成“目标接口→适配者接口”的逻辑转换。

## 极简Java示例

```java

// 1. 项目内统一的目标接口（支付标准）
public interface PayApi {
    void unifiedPay(String orderId); // 统一支付方法
}

// 2. 第三方老接口（适配者，无法修改）
public class OldThirdPay {
    // 老接口有额外参数，与项目标准不一致
    public void doPay(String orderId, String sign) {
        System.out.println("调用老接口支付，订单号：" + orderId + "，签名：" + sign);
    }
}

// 3. 适配器类（仅新增代码，适配老接口到新标准）
public class OldThirdPayAdapter implements PayApi {
    private OldThirdPay oldThirdPay; // 包装适配者

    public OldThirdPayAdapter(OldThirdPay oldThirdPay) {
        this.oldThirdPay = oldThirdPay;
    }

    @Override
    public void unifiedPay(String orderId) {
        // 接口转换：新接口参数 → 老接口参数
        oldThirdPay.doPay(orderId, "默认签名");
    }
}

// 测试调用
public class Test {
    public static void main(String[] args) {
        // 适配老接口，接入项目统一支付逻辑
        PayApi payApi = new OldThirdPayAdapter(new OldThirdPay());
        // 项目内调用统一接口，无需关心老接口的差异
        payApi.unifiedPay("O789012");
    }
}
```

# 五、缓存/权限等横切功能场景（适配：代理模式）

## 核心目标

新增缓存、权限校验、日志记录等横切功能时，不修改业务核心代码，仅通过代理类包装扩展。

## 实现思路

1. 定义业务核心接口，封装业务逻辑；

2. 实现真实业务类，专注核心业务；

3. 创建代理类，实现业务接口并包装真实业务对象；

4. 在代理类中，执行横切功能（如缓存），再调用真实业务逻辑。

## 极简Java示例

```java

import java.util.HashMap;
import java.util.Map;

// 1. 业务核心接口
public interface UserService {
    String queryUser(String userId); // 查询用户的核心方法
}

// 2. 真实业务类（原有，专注查询逻辑，无需修改）
public class UserServiceImpl implements UserService {
    @Override
    public String queryUser(String userId) {
        System.out.println("执行数据库查询，用户ID：" + userId);
        return "用户" + userId + "的信息"; // 模拟查询结果
    }
}

// 3. 代理类：新增缓存功能（仅新增代码）
public class UserServiceProxy implements UserService {
    private UserService target; // 包装真实业务对象
    private Map<String, String> cache = new HashMap<>(); // 缓存容器

    public UserServiceProxy(UserService target) {
        this.target = target;
    }

    @Override
    public String queryUser(String userId) {
        // 新增缓存逻辑（横切功能）
        if (cache.containsKey(userId)) {
            System.out.println("从缓存获取，用户ID：" + userId);
            return cache.get(userId);
        }
        // 调用原有业务逻辑
        String result = target.queryUser(userId);
        // 缓存结果
        cache.put(userId, result);
        return result;
    }
}

// 测试调用
public class Test {
    public static void main(String[] args) {
        // 原有逻辑：直接调用业务类（无缓存）
        UserService userService = new UserServiceImpl();
        userService.queryUser("U1001"); // 执行数据库查询

        // 扩展逻辑：通过代理类添加缓存（无修改原有业务类）
        UserService proxyService = new UserServiceProxy(userService);
        proxyService.queryUser("U1001"); // 第一次：数据库查询+缓存
        proxyService.queryUser("U1001"); // 第二次：直接从缓存获取
    }
}
```

# 六、落地关键补充

## 1. 优先选“最小改动”模式

- 规则类扩展（如优惠、支付）→ 策略模式；

- 功能增强（如日志加文件、IO加缓冲）→ 装饰器模式；

- 对象创建（如多类型商品、订单）→ 工厂模式；

- 接口兼容（如老系统对接、第三方适配）→ 适配器模式；

- 横切功能（如缓存、权限）→ 代理模式。

## 2. 结合Spring简化落地

- 策略模式：通过`@Autowired List<策略接口>`自动扫描所有实现类，无需手动创建实例；

- 工厂模式：通过`@Bean`注册不同产品实例，配合`@Qualifier`指定具体实现；

- 代理模式：直接使用Spring AOP替代手动代理，减少样板代码。

## 3. 避免过度设计

- 若业务几乎无扩展可能（如固定的基础工具类），无需强行抽象；

- 开闭原则是“对扩展开放”，而非“为扩展而扩展”，需结合实际业务迭代规划。

# 七、总结

1. 开闭原则落地的核心是**用抽象隔离变化**，设计模式是落地该原则的具体工具；

2. 不同业务场景对应不同模式：规则扩展用策略、功能增强用装饰器、对象创建用工厂、接口兼容用适配器、横切功能用代理；

3. 所有模式的核心逻辑一致：新增功能仅写新代码，不修改已有稳定代码。
> （注：文档部分内容可能由 AI 生成）